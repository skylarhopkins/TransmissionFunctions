% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sim.and.opt.R
\name{sim.and.opt}
\alias{sim.and.opt}
\title{Simulate epidemics with different transmission functions and fit multiple transmission functions to the simulated data}
\usage{
sim.and.opt(FOI, truegamma, pops, Nref, ks, initial.I, initial.S, time.out,
  time.samp, samp.sizes, nrestarts, ndatasets, outputlocation)
}
\arguments{
\item{FOI}{The Force of Infection value that you are simulating. If you want to do more than one at a time, you'll need to write a loop}

\item{truegamma}{The gamma value that you are simulating. If you want to do more than one at a time, you'll need to write a loop}

\item{pops}{A vector of constant population sizes in different populations that will experience simultaneous epidemics; you can include as few/many populations as desired}

\item{Nref}{Specify a reference population size around the middle of your population sizes for scaling across transmission functions}

\item{ks}{A vector containing the values of K (unitless density-dependence parameter) that you're simulating over}

\item{initial.I}{Vector of initial numbers of infected individuals in each pop. To keep the initial prevalence constant, you can scale these relative to pop sizes}

\item{initial.S}{Vector of initial numbers of infected individuals in each population. S+I should equal N.}

\item{time.out}{a single value indicating how many time units (e.g., 21 days days) the ODE should be simulated for - should be as long as largest time.samp}

\item{time.samp}{vector of the times when the populations were sampled, such as 0, 7, 14, and 21 days}

\item{samp.sizes}{vector of how many individuals will you sample in each population during each sampling event; same length as time.samp}

\item{nrestarts}{number of fits of each model to each dataset with different random starting parameters}

\item{ndatasets}{number of sample datasets for each value of K that you're simulating over}

\item{outputlocation}{The root directory where the output files should be stored}
}
\description{
'sim.and.opt' simulates epidemics in populations with different sizes (and thus densities, assuming constant area) using SIR
epidemiological models with variable amounts of density-dependence in the transmission function, ranging from
the density-dependent (DD) transmission function (K=1) to the frequency-dependent (FD) transmission function (K=0).
After simulating, the package fits three models to the simulated datasets to compare the accuracy of their
parameter estimates: the DD function, the FD function, and a flexible nonlinear function.
}
\details{
This function is the wrapper for the entire simulation and optimization process, using all other functions in the
contactr package. It runs simulations for a single FOI, a single gamma, and a range of Ks. You could write a loop
to run more than one FOI or gamma at a time, but given the long code run times, this is not advisable. The function
will save one output CSV file containing the parameter estimates for each dataset and each random restart for each
values of K.
}
\examples{
###Set Global Variables
##If you assign these variables outside of the function arguments, you cannot use the
##same names as the argument names, or else you'll get a recursive argument error.
##Sticking a period after each name solves this problem
#FOI.<-0.0001
#truegamma.<-0.1
#pops.<-c(100, 200, 500, 1000, 1500, 2000)
#Nref.<-1000
#ks.<-seq(0.0, 1.0, 0.1)
#initial.I.<-c(1,2,5,10,15,20)
#initial.S.<-pops.-initial.I.
#time.out. <- seq(0,150,by = 1)
#time.samp. <- seq(0,133, by = 7)
#samp.sizes. <- rep(100, length(time.samp.))
#nrestarts. = 1
#ndatasets. = 1
#outputlocation.<-getwd()
###Run the tool
##WARNING: this can take a very long time to run depending on ndatasets, nrestarts,
##and length of ks,so you might want to estimate run times (end_time - start_time)
##on a smaller subset first
#start_time <- Sys.time()
#sim.and.opt(FOI=FOI., truegamma=truegamma., pops=pops., Nref=Nref., ks=ks., initial.I=initial.I.,
#initial.S=initial.S., time.out=time.out., time.samp=time.samp., samp.sizes=samp.sizes.,
#nrestarts=nrestarts., ndatasets=ndatasets., outputlocation=outputlocation.)
#end_time <- Sys.time()
#end_time - start_time

}
